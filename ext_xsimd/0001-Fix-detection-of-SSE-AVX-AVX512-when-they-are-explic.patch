From 0ab6d6b520ef562f9f91babc0423559e3706c96a Mon Sep 17 00:00:00 2001
From: Dmitry Kazakov <dimula73@gmail.com>
Date: Mon, 20 May 2024 11:12:34 +0200
Subject: [PATCH] Fix detection of SSE/AVX/AVX512 when they are explicitly
 disabled by OS

Some CPU vulnerability mitigations may disable AVX functionality
on the hardware level via the XCR0 register. We should check that
manually to verify that OS actually allows us to use this feature.

See https://bugs.kde.org/show_bug.cgi?id=484622
---
 include/xsimd/config/xsimd_cpuid.hpp | 74 +++++++++++++++++++++++-----
 1 file changed, 61 insertions(+), 13 deletions(-)

diff --git a/include/xsimd/config/xsimd_cpuid.hpp b/include/xsimd/config/xsimd_cpuid.hpp
index 5a3e18c..3a3f051 100644
--- a/include/xsimd/config/xsimd_cpuid.hpp
+++ b/include/xsimd/config/xsimd_cpuid.hpp
@@ -75,6 +75,35 @@ namespace xsimd
                 best = neon::version() * neon;
 
 #elif defined(__x86_64__) || defined(__i386__) || defined(_M_AMD64) || defined(_M_IX86)
+
+                auto get_xcr0_low = []() noexcept
+                {
+                    uint32_t xcr0;
+
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+
+                    xcr0 = (uint32_t)_xgetbv(0);
+
+#elif defined(__GNUC__)
+
+                    __asm__ (
+                        "xorl %%ecx, %%ecx\n"
+                        "xgetbv\n"
+                        : "=a" (xcr0)
+                        :
+      #if defined(__i386__)
+                        : "ecx", "edx"
+      #else
+                        : "rcx", "rdx"
+      #endif
+                    );
+
+#else /* _MSC_VER < 1400 */
+#error "_MSC_VER < 1400 is not supported"
+#endif /* _MSC_VER && _MSC_VER >= 1400 */
+                    return xcr0;
+                };
+
                 auto get_cpuid = [](int reg[4], int func_id) noexcept
                 {
 
@@ -111,27 +140,46 @@ namespace xsimd
 
                 get_cpuid(regs, 0x1);
 
-                sse2 = regs[2] >> 26 & 1;
+                // OS can explicitly disable the usage of SSE/AVX extensions
+                // by setting an apropriate flag in CR0 register
+                //
+                // https://docs.kernel.org/admin-guide/hw-vuln/gather_data_sampling.html
+
+                unsigned sse_state_os_enabled = 1;
+                unsigned avx_state_os_enabled = 1;
+                unsigned avx512_state_os_enabled = 1;
+
+                bool osxsave = regs[2] >> 27 & 1;
+                if (osxsave) {
+
+                    uint32_t xcr0 = get_xcr0_low();
+
+                    sse_state_os_enabled = xcr0 >> 1 & 1;
+                    avx_state_os_enabled = xcr0 >> 2 & 1 & sse_state_os_enabled;
+                    avx512_state_os_enabled = xcr0 >> 6 & 1 & avx_state_os_enabled;
+                }
+
+                sse2 = regs[2] >> 26 & 1 & sse_state_os_enabled;
                 best = std::max(best, sse2::version() * sse2);
 
-                sse3 = regs[2] >> 0 & 1;
+                sse3 = regs[2] >> 0 & 1 & sse_state_os_enabled;
                 best = std::max(best, sse3::version() * sse3);
 
-                ssse3 = regs[2] >> 9 & 1;
+                ssse3 = regs[2] >> 9 & 1 & sse_state_os_enabled;
                 best = std::max(best, ssse3::version() * ssse3);
 
-                sse4_1 = regs[2] >> 19 & 1;
+                sse4_1 = regs[2] >> 19 & 1 & sse_state_os_enabled;
                 best = std::max(best, sse4_1::version() * sse4_1);
 
-                sse4_2 = regs[2] >> 20 & 1;
+                sse4_2 = regs[2] >> 20 & 1 & sse_state_os_enabled;
                 best = std::max(best, sse4_2::version() * sse4_2);
 
-                fma3_sse = regs[2] >> 12 & 1;
+                fma3_sse = regs[2] >> 12 & 1 & sse_state_os_enabled;
                 if (sse4_2)
                     best = std::max(best, fma3<xsimd::sse4_2>::version() * fma3_sse);
 
                 get_cpuid(regs, 0x80000001);
-                fma4 = regs[2] >> 16 & 1;
+                fma4 = regs[2] >> 16 & 1 & sse_state_os_enabled;
                 best = std::max(best, fma4::version() * fma4);
 
                 // sse4a = regs[2] >> 6 & 1;
@@ -140,29 +188,29 @@ namespace xsimd
                 // xop = regs[2] >> 11 & 1;
                 // best = std::max(best, XSIMD_X86_AMD_XOP_VERSION * xop);
 
-                avx = regs[2] >> 28 & 1;
+                avx = regs[2] >> 28 & 1 & avx_state_os_enabled;
                 best = std::max(best, avx::version() * avx);
 
                 fma3_avx = avx && fma3_sse;
                 best = std::max(best, fma3<xsimd::avx>::version() * fma3_avx);
 
                 get_cpuid(regs, 0x7);
-                avx2 = regs[1] >> 5 & 1;
+                avx2 = regs[1] >> 5 & 1 & avx_state_os_enabled;
                 best = std::max(best, avx2::version() * avx2);
 
                 fma3_avx2 = avx2 && fma3_sse;
                 best = std::max(best, fma3<xsimd::avx2>::version() * fma3_avx2);
 
-                avx512f = regs[1] >> 16 & 1;
+                avx512f = regs[1] >> 16 & 1 & avx512_state_os_enabled;
                 best = std::max(best, avx512f::version() * avx512f);
 
-                avx512cd = regs[1] >> 28 & 1;
+                avx512cd = regs[1] >> 28 & 1 & avx512_state_os_enabled;
                 best = std::max(best, avx512cd::version() * avx512cd * avx512f);
 
-                avx512dq = regs[1] >> 17 & 1;
+                avx512dq = regs[1] >> 17 & 1 & avx512_state_os_enabled;
                 best = std::max(best, avx512dq::version() * avx512dq * avx512cd * avx512f);
 
-                avx512bw = regs[1] >> 30 & 1;
+                avx512bw = regs[1] >> 30 & 1 & avx512_state_os_enabled;
                 best = std::max(best, avx512bw::version() * avx512bw * avx512dq * avx512cd * avx512f);
 
 #endif
-- 
2.34.1

